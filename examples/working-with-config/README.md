<!-- DO NOT MODIFY                                            -->
<!-- this file is generated by mdref                          -->
<!-- from ../../docsrc/examples/working-with-config/README.md -->

# Working with Configurations

This tour illustrates the basic configuration management. The library provides
an extensible framework to bring together configuration settings
and configuration target.

It covers the following basic scenarios:

- [`basic`](#basic-configuration-management) Basic configuration management illustrating a simple configuration use case.
- [`generic`](#handling-of-arbitrary-configuration) Handling of arbitrary configuration data.
- [`central`](#central-configuration) Using central configuration files.
- [`configset`](#working-with-config-sets) Using preconfigured config sets.
- [`write`](#providing-new-config-object-types) Providing new Config Object Types
- [`consume`](#preparing-objects-to-be-configured-by-the-config-management) Preparing Objects to be Configured by the Config Management
- [`applier`](#using-config-appliers-for-generic-config-data-providers) Using Config Appliers for Generic Config Data Providers

## Running the example

You can call the main program with the name of the scenario under `examples/working-with-config`.

## General Architecture

Configuration is managed by a configuration context. This context is configured with
a set of context object types. A config type has a type name and provides a deserialization
of an appropriately types text representation of the setting of the config object.
With the type taken from the serialization format the context is able to transform
the content again to a configuration object.

A configuration object contains some configuration data. Its task is to apply these settings
to supported configuration target objects, for example other contexts.
A configuratuion object can be responsible for completely different target objects.

Configuration objects are then applied to a configuration context, which keeps a queue
of applied objects. A configurable target object then requests its configuration from
the configuration context.

It is important to keep in mind that this reverts the configuration direction. Applying
a configuration object to the configuration management does NOT configure
applicable objects. Instead, an object, which wants to be configured must ask the config
management to do so. THis has been designed tis way to keep the config management free
from references to any configurable object. This enables the Go garbage collection
to delete such objects if they are not used anymore. The config management does not
prevent such garbage collection. Both parts, the configuration context and the configurable
object are independently garbage collectable.

If an object want to be configured automatically, it requires a reference to the
configuration context (see [consumption tour](#preparing-objects-to-be-configured-by-the-config-management))

The context object supports incremental updates by providing
a target specific `Updater` object, which keeps track of already applied configuration
objects. This way, during runtime further configuration objects can be applied. The
configurable target object can request the context for those incremental updates using
its `Updater` object.

## Walkthrough

### Basic Configuration Management

To use the configuration management an appropriate configuration context object
is required. The most simple way to achieve such an object is to use
the default context or a separate context based on the default context.

The default context is initialized with all the configuration object types
known to the library or attached later by a using library.

```go
	ctx := config.DefaultContext()
```

The configuration context handles configuration objects.
A configuration object is any object implementing
the `config.Config` interface. The task of a config object
is to apply configuration to some target object.

One such object is our example config object defined in `examples/myconfig`.

```go
	cfg := myconfig.NewConfig("service.provider.com")
	cfg.Credentials = &myconfig.Credentials{
		Username: "appuser",
		Password: "apppass",
	}
```

Here, we can specify some settings for out example application.
Typically, those config objects can be serialized to and deserialized from 
a YAML-based text representation.

```go
	spec, err := json.MarshalIndent(cfg, "  ", "  ")
	if err != nil {
		return errors.Wrapf(err, "marshal config")
	}

	fmt.Printf("this is our configuration object:\n")
	helper.Output("format", func() {
		fmt.Printf("  %s\n", string(spec))
	})
```

The serialized format look as follows:

```yaml
  {
    "type": "application.config.acme.org",
    "serviceAddress": "service.provider.com",
    "credentials": {
      "username": "appuser",
      "password": "apppass"
    }
  }
```

Like all the other manifest based descriptions this format always includes
a type field, which can be used to deserialize a specification into
the appropriate object.
This can be done by the config context, which keeps a set of known (registered)
config object types. It accepts YAML or JSON.

```go
	o, err := ctx.GetConfigForData(spec, nil)
	if err != nil {
		return errors.Wrapf(err, "deserialize config")
	}

	if diff := deep.Equal(o, cfg); len(diff) != 0 {
		fmt.Printf("diff:\n%v\n", diff)
		return fmt.Errorf("invalid des/erialization")
	}
```

Regardless what variant is used (direct specification object or descriptor)
the config object can be added to a config context.

```go
	err = ctx.ApplyConfig(cfg, "explicit setting")
	if err != nil {
		return errors.Wrapf(err, "cannot apply config")
	}
```

Every config object implements the
`ApplyTo(ctx config.Context, target interface{}) error` method.
It takes an object, which wants to be configured.
The config object then decides, whether it provides
settings for the given object and calls the appropriate
methods on this object (after a type cast).

Here is the code snippet from the apply method of our config object
config object ([examples/myconfig/type.go](../../../examples/myconfig/config.go)):

```go
func (c *Config) ApplyTo(_ cpi.Context, tgt interface{}) error {
	switch t := tgt.(type) {
	// if the target is a credentials context
	// configure the credentials to be used for the
	// described OCI repository.
	case credentials.Context:
		// determine the consumer id for our target repository.
		if c.Credentials != nil && c.Credentials.Username != "" && c.Credentials.Password != "" {
			id := identity.GetConsumerId(c.ServiceAddress)

			// create the credentials.
			if creds := c.GetCredentials(); creds != nil {
				// configure the targeted credential context with
				// the provided credentials (see previous examples).
				t.SetCredentialsForConsumer(id, creds)
			}
		}

	// if the target consumes an OCI repository, propagate
	// the provided OCI repository ref.
	case ConfigTarget:
		t.SetServiceAddress(c.ServiceAddress)

	// all other targets are ignored, we don't have
	// something to set at these objects.
	default:
		return cpi.ErrNoContext(TYPE)
	}
	return nil
}
        ...
```

As can be seen a config object may support multiple config targets, and
configure those with different parts of its settings. Here, the
credentials are used to configure the credentials context, and the
service address to configure an object supporting the 
`ConfigTarget`
interface.


This way the config mechanism reverts the configuration
request, it does not actively configure something, instead
an object, which wants to be configured calls the config
context to apply pending configs.
To do this the config context manages a queue of config objects
and applies them to an object to be configured.

No we can request the configuration of an object by calling
the ` ApplyAllTo` method on the configuration context
for this object. Here, we use an `ExampleTarget` object which
implements the target interface of our config object.

```go
	tgt := &ExampleTarget{}

	err = ctx.ApplyAllTo(tgt)
	if err != nil {
		return errors.Wrapf(err, "request configuration")
	}
```

The result is then

```
configured address is "service.provider.com"
```

<!-------------------------------------------------------------------------------->

### Handling of Arbitrary Configuration

The config management not only manages configuration objects for any
other configurable object, it also provides a configuration object of
its own. The task of this object is to handle other configuration objects
to be applied to a configuration object. The target of this configuration
object is therefore the configuration context itself.

```go
	generic := configcfg.New()
```

The generic config object holds a list of any other config objects,
or their specification formats.

We recycle our application config from the last example to get
a config object to be added to our generic config object.

```go
	subcfg := myconfig.NewConfig("localhost:8080")
```

Now, we can add this config object as nested configuration to
our generic config list.

```go
	err := generic.AddConfig(subcfg)
	if err != nil {
		return errors.Wrapf(err, "adding config")
	}
```

As we have seen in our previous example, config objects are typically
serializable and deserializable. This also holds for the generic config
object of the config context.

```go
	spec, err := json.MarshalIndent(generic, "  ", "  ")
	if err != nil {
		return errors.Wrapf(err, "marshal aggregated config")
	}

	fmt.Printf("this is a generic configuration object:\n")
	helper.Output("format", func() {
		fmt.Printf("%s\n", string(spec))
	})
```

The result is a config object hosting a list (here with 1 entry)
of other config object specifications.

```
configured address is "localhost:8080"
```

The generic config object can be added to a config context, again, like
any other config object. If it is asked to configure a configuration
context it uses the methods of the configuration context to apply the
contained list of config objects.
Therefore, all config objects applied to a configuration context are
asked to configure the configuration context itself when queued to the
list of applied configuration objects.

```go
	ctx := config.DefaultContext()
	err = ctx.ApplyConfig(generic, "generic setting")
	if err != nil {
		return errors.Wrapf(err, "cannot apply config")
	}
```

If we now ask the context, again, to configure our application,
the nested config applies its value.

```go
	tgt := &ExampleTarget{}

	err = ctx.ApplyAllTo(tgt)
	if err != nil {
		return errors.Wrapf(err, "request configuration")
	}
```

The result is the same as in the previous example

```
configured address is "localhost:8080"
```


The very same mechanism is used to provide central configuration in a
configuration file for the OCM ecosystem, as will be shown in the next example.

<!-------------------------------------------------------------------------------->

### Central Configuration

Although the configuration of a context can
be done by a sequence of explicit calls to a configuration context
according to the mechanism
shown in the examples before, it provides a simple
library function, which can be used to configure a
context and all related other contexts with a single call
based on arbitrary central configuration files.

```go
	ctx := config.DefaultContext()

	err := cfgutils.Configure(ctx, ".appconfig")
	if err != nil {
		return errors.Wrapf(err, "configuration")
	}
```

Here, we use the file `.appconfig`.
This file typically contains the serialization of such a generic
configuration specification shown in the previous example 
(or any other serialized configuration object),
enriched with specialized config specifications for
credentials, default repositories, or any
other configuration specifications.

Now, we can again configure our example target as shown before:

```go
	tgt := &ExampleTarget{}

	err = ctx.ApplyAllTo(tgt)
	if err != nil {
		return errors.Wrapf(err, "request configuration")
	}
```

and achieve the same result as before.

```
configured address is "localhost:8080"
```

#### Standard Configuration Files

Most important for such configurations are the credentials.
Because a library or application might embrace lots of network based remote
services or storage technologies, there are typically multiple technology
specific ways to configure credentials for command line tools.
Using the credentials settings shown in the [next-tour](../working-with-credentials/README.md),
this library also provide a credential management. It is based on
this config management and provides an own config object.
It is possible to specify credentials for all
required purposes, and the configuration management provides
an extensible way to embed native technology specific ways
to provide credentials just by adding an appropriate type
of credential repository, which reads the specialized storage and
feeds it into the credential context. Those specifications
can be added via the credential configuration object to
the central configuration.

One such repository type is the Docker config type. It
reads a `dockerconfig.json` file and feeds in the credentials
to be used for OCI registries.

We first create the specification for a new credential repository of
type `dockerconfig` describing the default location
of the standard Docker config file.

```go
	credspec := dockerconfig.NewRepositorySpec("~/.docker/config.json", true)

	// add this repository specification to a credential configuration.
	ccfg := credcfg.New()
	err = ccfg.AddRepository(credspec)
	if err != nil {
		return errors.Wrapf(err, "invalid credential config")
	}
```

By adding the default location for the standard Docker config
file, all credentials provided by the `docker login` command
are available for our program, also. This way any required technology
can be embedded and this module provides a uniform way to access
this information regardless of its source.

A typical minimal <code>.appconfig</code> file can be composed as follows.
We add this config object to an empty generic configuration object
and print the serialized form. The result can be used as
default initial configuration file.

```go
	cfg := configcfg.New()
	err = cfg.AddConfig(ccfg)

	spec, err := yaml.Marshal(cfg)
	if err != nil {
		return errors.Wrapf(err, "marshal ocm config")
	}
```

The result should looks as follows:

```yaml
configurations:
- repositories:
  - repository:
      dockerConfigFile: ~/.docker/config.json
      propagateConsumerIdentity: true
      type: DockerConfig
  type: credentials.config.mandelsoft.de
type: generic.config.mandelsoft.de
```

Because of the ordered map keys the actual output looks a little bit confusing: 
don't be worried about the location of the `type` field.


Besides from a file, such a config can be provided as data, also,
taken from any other source, for example from a Kubernetes secret.

```go
	err = cfgutils.ConfigureByData(ctx, spec, "from data")
	if err != nil {
		return errors.Wrapf(err, "configuration")
	}
```

<!-------------------------------------------------------------------------------->

#### Templating

The configuration library function does not only read the
config file, it also applies [*spiff*](https://github.com/mandelsoft/spiff)
processing to the provided YAML/JSON content. *Spiff* is an
in-domain yaml-based templating engine. Therefore, you can use
any spiff dynaml expression to define values or even complete
sub structures.

```go
	cfg = configcfg.New()
	ccfg = credcfg.New()
	cspec := credentials.CredentialsSpecFromList("clientCert", `(( read("~/acme/keys/myClientCert.pem") ))`)
	id := credentials.NewConsumerIdentity(identity.CONSUMER_TYPE, "hostname", "service.acme.corp")
	ccfg.AddConsumer(id, cspec)
	cfg.AddConfig(ccfg)
```

This config object is not directly usable, because the cert value is not
a valid certificate. We use it here just to generate the serialized form.

```yaml
configurations:
- consumers:
  - credentials:
    - credentialsName: Credentials
      properties:
        clientCert: (( read("~/acme/keys/myClientCert.pem") ))
      type: Credentials
    identity:
      hostname: service.acme.corp
      type: service.acme.corp
  type: credentials.config.mandelsoft.de
type: generic.config.mandelsoft.de
```

If this is used with one of the above library functions, the finally generated
config object will contain the read file content, which is hopefully a
valid certificate.

<!-------------------------------------------------------------------------------->

### Working with Config Sets

A `ConfigSet` represents, like configuration objects of the configuration context, a list of
configuration objects, but it is not itself a configuration object. Instead, it can be used
to configure named lists of configuration objects at a configuration context.

We configure our application config object, here:

```go
	set := config.NewConfigSet("application")
	set.AddConfig(myconfig.NewConfig("localhost:8080"))
```

When adding a set to a context it gets assigned a name:

```go
	ctx.AddConfigSet("application", set)
```

Once added to a context, sets can then be activated with a single API call by their assigned name.

```go
	ctx.ApplyConfigSet("application")
```

Now, the included config objects are applied to the configuration context, and
our application can be configured as already shown in the previous examples

```go
	err = ctx.ApplyAllTo(tgt)
	if err != nil {
		return errors.Wrapf(err, "request configuration")
	}
```

and provides the expected result:

```
configured address is "localhost:8080"
```

Config sets can not only be configured via the API, but the config object type
of the configuration management, also. Here, we configure a new set called `modified`.

```go
	cfg := configcfg.New()
	set = config.NewConfigSet("application")
	set.AddConfig(myconfig.NewConfig("service.acme.corp:443"))
	cfg.AddConfigSet("modified", set)
```

This way preconfigured sets can be provided by central configuration sources and
enabled just by an API call using the set name.

But even the activation of previously defined sets can be handled by ut config object.

After activating the `modified` set with

```go
	ctx.ApplyConfigSet("modified")
```

and reconfiguring our config target, the result is adapted, accordingly:

```
modified address is "service.acme.corp:443"
```

<!-------------------------------------------------------------------------------->

### Providing new Config Object Types

So far, we just showed how to use config types to configure objects.
But the configuration management is highly extensible, and it is quite
simple to provide new config types, which can be used to configure
any new or existing object, which is prepared to consume configuration.

The next [chapter](#preparing-objects-to-be-configured-by-the-config-management) will show more elaborated way to
consume configuration and how to prepare an
object to be automatically configurable by
the configuration management. 

Now, we will show how new configuration object types can be
implemented and registered to be usable by the configuration management.

#### The Configuration Object Type

Typically, every kind of configuration object lives in its own package,
which always have the same layout. Our application congig example
object is defined in package [myconfig](../../../examples/myconfig/config.go)

A configuration object has a *type*, the configuration type. Therefore,
the package declares a constant `TYPE`. Here, we use the name `application.config.acme.org`.

It is the name of our new configuration object type.
To be globally unique, it should always end with a
DNS domain owned by the provider of the new type.

```go
const TYPE = "application.config.acme.org"
```

Next, we need a Go type. `Config` is the new Go type for the
config specification covering our example configuration. Because every config
object type uses its own package, always the same generic name can be used.
It just encapsulates our application configuration values. We use, the server
address and optionally credentials (basically this is not a good idea, because it 
could already be configured with other config objects. We just added this for
demonstration puropses)
used to configure the examples of our tour.

```go
type Config struct {
	// ObjectVersionedType is the base type providing the type feature
	// for (config) specifications.
	runtime.ObjectVersionedType `json:",inline"`

	// ServiceAddress is the address of the service intended to be used by our
	// application.
	ServiceAddress string `json:"serviceAddress"`

	// Credentials are the credentials required to access the service
	// located at ServiceAddress.
	Credentials *Credentials `json:"credentials,omitempty"`
}

type Credentials struct {
	Username string `json:"username,omitempty"`
	Password string `json:"password,omitempty"`
}

// A config object object must implememt the config.Config interface.
var _ config.Config = (*Config)(nil)
```

Every config type structure must contain a field (and the appropriate methods)
for storing the config type name. This is done by embedding the
type `runtime.ObjectVersionedType` from the `runtime` package. This package
contains everything to work with specification objects and
serialization/deserialization.

Additional fields describe our desired configuration values.

A config type typically provides a constructor for a config object of
this type:

```go
func NewConfig(addr string) *Config {
	return &Config{
		ObjectVersionedType: runtime.NewVersionedTypedObject(TYPE),
		ServiceAddress:      addr,
	}
}
```

Additional setters can be used to configure the configuration object,
for example by mapping more complex objects into configuration attributes
prepared to be serialized.

```go

// SetCredentials sets the credentials required by the application.
func (c *Config) SetCredentials(user, pass string) {
	c.Credentials = &Credentials{
		Username: user,
		Password: pass,
	}
}

// SetAddress sets address of used service.
func (c *Config) SetAddress(desc string) {
	c.ServiceAddress = desc
}
```

Getters can be used to prepare configuration attributes and make them available
to the application by converting values into more complex Go abstractions finally
usable by the application

```go
func (c *Config) GetCredentials() credentials.Credentials {
	if c.Credentials != nil && c.Credentials.Username != "" && c.Credentials.Password != "" {
		return credentials.NewCredentials(utils.Properties{
			identity.ATTR_USERNAME: c.Credentials.Username,
			identity.ATTR_PASSWORD: c.Credentials.Password,
		})
	}
	return nil
}
```

The utility function `runtime.CheckSpecification` can be used to
check a byte sequence to be a valid specification.
It just checks for a valid YAML document featuring a non-empty
`type` field:

```go

// CheckSpecification checks a byte sequence to describe a
// valid minimum specification object.
func CheckSpecification(data []byte) error {
	var obj ObjectTypedObject

	err := DefaultYAMLEncoding.Unmarshal(data, &obj)
	if err != nil {
		return errors.ErrInvalidWrap(err, "repository specification", string(data))
	}
	if obj.GetType() == "" {
		return errors.ErrInvalidWrap(fmt.Errorf("non-empty type field required"), "repository specification", string(data))
	}
	return nil
}
```

The most important method to implement is `ApplyTo(_ cpi.Context, tgt interface{}) error`,
which must be implemented by all configuration objects.
Its task is to apply the described configuration settings to a dedicated
object.

```go
func (c *Config) ApplyTo(_ cpi.Context, tgt interface{}) error {
	switch t := tgt.(type) {
	// if the target is a credentials context
	// configure the credentials to be used for the
	// described OCI repository.
	case credentials.Context:
		// determine the consumer id for our target repository.
		if c.Credentials != nil && c.Credentials.Username != "" && c.Credentials.Password != "" {
			id := identity.GetConsumerId(c.ServiceAddress)

			// create the credentials.
			if creds := c.GetCredentials(); creds != nil {
				// configure the targeted credential context with
				// the provided credentials (see previous examples).
				t.SetCredentialsForConsumer(id, creds)
			}
		}

	// if the target consumes an OCI repository, propagate
	// the provided OCI repository ref.
	case ConfigTarget:
		t.SetServiceAddress(c.ServiceAddress)

	// all other targets are ignored, we don't have
	// something to set at these objects.
	default:
		return cpi.ErrNoContext(TYPE)
	}
	return nil
}
```

It is free to configure any type of object, even multiple ones.
Therefore, it decides, whether it is able to handle a dedicated type of target
object and how to configure it. This way a configuration object
may apply is settings or even parts of its setting to any kind of target object.

Our configuration object supports two kinds of target objects:

If the target is a credentials context it configures the credentials to be
  used for tour application service (see also the [credential management tour](../working-with-credentials/README.md).

But we want to accept more types of target objects. Therefore, we
introduce an own interface declaring the methods required for applying
some configuration settings (here, our service address).

```go

// ConfigTarget consumes a repository name.
type ConfigTarget interface {
	SetServiceAddress(r string)
}
```

By checking the target object against this interface, we are able
to configure any kind of object, as long as it provides the necessary
configuration methods.

Now, we are nearly prepared to use our new configuration, there is just one step
missing. To enable the automatic recognition of our new type (for example
in a central config file), we have to tell the configuration management
about the new type. This is done by an `init()` function in our config package.

Here, we call a registration function,
which gets called with a dedicated type object for the new config type.
A *type object* describes the config type, its type name, how
it is serialized and deserialized and some description.
We use a standard type object, here, instead of implementing
an own one. It is parameterized by the Go pointer type (`*Config`) for
our specification object.

```go
func init() {
	// register the new config type, so that is can be used
	// by the config management to deserialize appropriately
	// typed specifications.
	cpi.RegisterConfigType(cpi.NewConfigType[*Config](TYPE, "this is a config object type based on the example config data."))
}
```

Without this registration the new config object could be used via API calls,
but the deserialization is not known by the configuration context. There, it could
not be used as part of a configuration file.

#### Using our new Config Object

After preparing a new special config type
we can feed it into the config management.

A usual, we gain access to our configuration context.

```go
	ctx := config.DefaultContext()
```

To setup our environment we create our new config based on the desired settings
and apply it to the config context.

```go
func (c *Config) ApplyTo(_ cpi.Context, tgt interface{}) error {
	switch t := tgt.(type) {
	// if the target is a credentials context
	// configure the credentials to be used for the
	// described OCI repository.
	case credentials.Context:
		// determine the consumer id for our target repository.
		if c.Credentials != nil && c.Credentials.Username != "" && c.Credentials.Password != "" {
			id := identity.GetConsumerId(c.ServiceAddress)

			// create the credentials.
			if creds := c.GetCredentials(); creds != nil {
				// configure the targeted credential context with
				// the provided credentials (see previous examples).
				t.SetCredentialsForConsumer(id, creds)
			}
		}

	// if the target consumes an OCI repository, propagate
	// the provided OCI repository ref.
	case ConfigTarget:
		t.SetServiceAddress(c.ServiceAddress)

	// all other targets are ignored, we don't have
	// something to set at these objects.
	default:
		return cpi.ErrNoContext(TYPE)
	}
	return nil
}
```

Now, we should already be prepared to get the credentials configured
in our config object.

```go
	id := identity.GetConsumerId(examplecfg.ServiceAddress)
	fmt.Printf("required credentials: %s\n", id)

	// the returned credentials are provided via an interface, which might change its
	// content, if the underlying credential source changes.
	creds, err := credentials.CredentialsForConsumer(credentials.DefaultContext(), id)
	if err != nil {
		return errors.Wrapf(err, "credentials")
	}

	helper.Output("credentials", func() {
		fmt.Printf("credentials: %s\n", creds)
	})
```

The default credential context uses the default configuration context
and is therefore able to determine the credentials for the requested
consumer scenario (more details about using the credential context are
shown in the [credential management tour](../working-with-credentials/README.md)).

```yaml
credentials: {"password":"testpassword","username":"testuser"}
```


#### Using in the Central Configuration

Because of the registration of the new credential type, such a specification can
now be added to a serialized config file, also.

```go
	cfg := configcfg.New()
	err = cfg.AddConfig(examplecfg)

	spec, err := yaml.Marshal(cfg)
	if err != nil {
		return errors.Wrapf(err, "marshal central config")
	}

	// the result is a minimal configuration file
	// just providing our new example configuration.

	fmt.Printf("this a typical config file:\n")
	helper.Output("config file", func() {
		fmt.Printf("%s\n", string(spec))
	})
```

The resulting config file looks as follows:

```yaml
configurations:
- credentials:
    password: testpassword
    username: testuser
  serviceAddress: localhost:8080
  type: application.config.acme.org
type: generic.config.mandelsoft.de
```

#### Applying to our Configuration Interface

Above, we added a new kind of target, the `ConfigTarget` interface.
By providing an implementation for this interface, we can directly request the
configuration of such an object using the config management.
We just provide a simple implementation for this interface, just storing the configured
repository specification.

```go
type ExampleTarget struct {
	address string
}

var _ myconfig.ConfigTarget = (*ExampleTarget)(nil)

func (e *ExampleTarget) SetServiceAddress(r string) {
	e.address = r
}
```

The context management now is able to apply our config to such an object.

```go
	tgt := &ExampleTarget{}
	err = ctx.ApplyAllTo(tgt)
	if err != nil {
		return errors.Wrapf(err, "cannot configure")
	}
	helper.Output("result", func() {
		fmt.Printf("configured address is %q\n", tgt.address)
	})
```

It finally sets the configured value:

```
configured address is "localhost:8080"
```

This way any specialized configuration object can be added
by a user of the library. It can be used to configure
existing objects or even new object types, even in combination.

What is still required is a way
to implement new config targets, objects, which wants
to be configured and which autoconfigure themselves when
used. Our simple repository target is just an example
for some kind of ad-hoc configuration.
A complete scenario is shown in the next example.

<!-------------------------------------------------------------------------------->

### Preparing Objects to be Configured by the Config Management

We already have our new acme.corp config object type,
and a target interface which must be implemented by a target
object to be configurable. The last example showed how
such an object can be configured in an ad-hoc manner
by directly requesting to be configured by the config
management.

Now, we want to provide an object, which configures
itself when used.
Therefore, we introduce a Go type `ServiceAddressProvider`.
It should be an object, which is
able to provide an address of an acme service.
It has a setter and a getter (the setter is
provided by our ad-hoc `ExampleTarget` implementation for an
object configurable with an address by our config object).

To be able to configure itself, the object must know about
the config context it should use to configure itself.

Therefore, our type contains an additional field `updater`.
Its type `cpi.Updater` is a utility provided by the configuration
management, which holds a reference to a configuration context
and is able to
configure an object based on a managed configuration
watermark. It remembers which config objects from the
config queue are already applied, and replays
the config objects applied to the config context
since the last update.

Finally, a mutex field is contained, which is used to
synchronize updates, later.

```go
type ServiceAddressProvider struct {
	lock sync.Mutex
	// cpi.Updater is a utility, which is able to
	// configure an object based on a managed configuration
	// watermark. It remembers which config objects from the
	// config queue are already applied, and replays
	// the config objects applied to the config context
	// after the last update.
	updater cpi.Updater
	ExampleTarget
}
```

For this type a constructor is provided, which initializes
the `updater` field with the desired configuration context.

```go
func NewServiceAddressProvider(ctx cpi.ContextProvider) *ServiceAddressProvider {
	p := &ServiceAddressProvider{}
	// To do its work, the updater needs a connection to
	// the config context to use and the object, which should be
	// configured.
	p.updater = cpi.NewUpdater(ctx.ConfigContext(), p)
	return p
}
```

The magic now happens in the methods provided
by our configurable object.
The first step for methods of configurable objects
dependent on potential configuration is always
to update itself using the embedded updater, before
some action is executed potentially affected by configuration changes.

Please note, the configuration management reverses the
request direction. Applying a config object to
the config context does not configure dependent objects,
it just manages a config queue, which is used by potential
configuration targets to configure themselves.
The actual configuration action is always initiated
by the object, which wants to be configured.
The reason for this is to avoid references from the
management to managed objects. This would prohibit
the garbage collection of all configurable objects
as long as the configuration context exists.

```go
func (p *ServiceAddressProvider) GetServiceAddress() (string, error) {
	p.lock.Lock()
	defer p.lock.Unlock()

	err := p.updater.Update()
	if err != nil {
		return "", err
	}
	// now, we can do our regular function, aka
	// providing a repository ref.
	return p.address, nil
}
```

After defining our provider type we can now start to use it
together with the configuration management and our configuration object.

As usual, we first determine out context to use.

```go
	ctx := config.DefaultContext()
```

Now, we create our provider as configurable object by binding it
to the config context.

```go
	prov := NewServiceAddressProvider(ctx)
```

If we ask now for a service address we will get the empty
answer, because nothing is configured, so far.

```go
	addr, err := prov.GetServiceAddress()
	if err != nil {
		errors.Wrapf(err, "get repo")
	}
	if addr != "" {
		return fmt.Errorf("Oops, found address %q", addr)
	}
```

In the next step, we apply our config from the last example. Therefore, we create and 
initialize the config object with our desired settings and apply it to the config
context.

```go
	examplecfg := myconfig.NewConfig("localhost:8080")
	examplecfg.SetCredentials("testuser", "testpass")
	err = ctx.ApplyConfig(examplecfg, "special acme config")
	if err != nil {
		errors.Wrapf(err, "apply config")
	}
```

Without any further action, asking for the provider now will return the
configured address. The configurable object automatically catches the
new configuration from the config context.

```go
	addr, err = prov.GetServiceAddress()
	if err != nil {
		errors.Wrapf(err, "get service address")
	}
	if addr == "" {
		return fmt.Errorf("no service address provided")
	}
	helper.Output("result", func() {
		fmt.Printf("using service address: %q\n", addr)
	})
```

It returns the configured service address:

```yaml
using service address: "localhost:8080"
```

Additionally, we should also be prepared to get the credentials,
our config object configures the provider as well as
the credential context.

```go
	id := identity.GetConsumerId(examplecfg.ServiceAddress)
	fmt.Printf("required credentials: %s\n", id)

	// the returned credentials are provided via an interface, which might change its
	// content, if the underlying credential source changes.
	// The default credential context uses the default config context,
	// therefore it finds the expected settings.
	creds, err := credentials.CredentialsForConsumer(credentials.DefaultContext(), id)
	if err != nil {
		return errors.Wrapf(err, "credentials")
	}

	helper.Output("credentials", func() {
		fmt.Printf("credentials: %s\n", creds)
	})
```

This gives us the following output:

```yaml
credentials: {"password":"testpass","username":"testuser"}
```

<!-------------------------------------------------------------------------------->


### Using Config Appliers for Generic Config Data Providers

A typical config object bundles the configuration logic
with particular configuration fields.
This could be problematic if generic data stores 
should be used to store configuration data. Here, we
have a third element, the technical access to the
data repository. This would require to create
config objects for every combination of
repository, config fields and config logic.
To circumvent this, the configuration management
supports a decoupling of the data access from application
logic by introducing `ConfigAppliers`.

A `ConfigApplier` is restricted to the pure configuration logic.
It takes arbitrary config data
and applies it according to its own logic.
The storage access to retrieve the data is left to
a storage technology specific implementation of
a config object just reading the data and applying
a named config applier.

Such a config object features properties to identify 
the config attributes in a data storage and the name
of the config applier.

Our demo applier expects a string as configuration value
and configures our well-known `ConfigTarget`
interface used to configure our demo application.


```go

const APPLIER = "config.acme.corp"

type ConfigApplier struct {
}

var _ cpi.ConfigApplier = (*ConfigApplier)(nil)

func (a *ConfigApplier) ApplyConfigTo(ctx config.Context, data, target any) error {
	if t, ok := target.(myconfig.ConfigTarget); ok {
		d, ok := data.(string)
		if ok {
			t.SetServiceAddress(d)
		} else {
			return fmt.Errorf("invalid config data: expceted a string value")
		}
	}
	return cpi.ErrNoContext(myconfig.TYPE)
}
```

Like configuration object types, Config appliers are registered
at a configuration context. Default appliers are globally
registered using an `init`function and implicitly used for all
non-initial contexts.

```go
func init() {
	cpi.RegisterConfigApplier(APPLIER, &ConfigApplier{})
}
```

Appliers are used together with config objects providing generic
configuration data. For test purposes the library provides
one such config object types using arbitrary inline data for configuration.

```go
package data

import (
	"encoding/json"

	"github.com/mandelsoft/ctxmgmt/config/cpi"
	"github.com/mandelsoft/ctxmgmt/utils/runtime"
	"github.com/mandelsoft/goutils/errors"
)

const (
	ConfigType   = "data" + cpi.CONFIG_TYPE_SUFFIX
	ConfigTypeV1 = ConfigType + runtime.VersionSeparator + "v1"
)

func init() {
	cpi.RegisterConfigType(cpi.NewConfigType[*Config](ConfigType, usage))
	cpi.RegisterConfigType(cpi.NewConfigType[*Config](ConfigTypeV1, usage))
}

// Config describes arbitrary configuration data
// // passed to a named ConfigApplier.
type Config struct {
	runtime.ObjectVersionedType `json:",inline"`
	Data                        json.RawMessage `json:"data,omitempty"`
	Applier                     string          `json:"applier"`
}

// New creates a new memory ConfigSpec.
func New(applier string, data interface{}) (*Config, error) {
	var rendered json.RawMessage
	var err error

	if data != nil {
		switch d := data.(type) {
		case []byte:
			var m interface{}
			err = runtime.DefaultYAMLEncoding.Unmarshal(d, &m)
			if err != nil {
				return nil, err
			}
			rendered, _ = json.Marshal(m)
		default:
			rendered, err = json.Marshal(d)
			if err != nil {
				return nil, err
			}
		}
	}
	return &Config{
		ObjectVersionedType: runtime.NewVersionedTypedObject(ConfigType),
		Applier:             applier,
		Data:                rendered,
	}, nil
}

func (c *Config) GetType() string {
	return ConfigType
}

func (c *Config) ApplyTo(ctx cpi.Context, target interface{}) error {
	a := ctx.ConfigAppliers().Get(c.Applier)
	if a == nil {
		return errors.ErrUnknown(cpi.KIND_CONFIGAPPLIER)
	}
	var data any
	err := json.Unmarshal(c.Data, &data)
	if err != nil {
		return err
	}
	return a.ApplyConfigTo(ctx, data, target)
}

const usage = `
The config type <code>` + ConfigType + `</code> can be used to pass arbitrary 
configuration data to a named config applier known to the config context:

<pre>
    type: ` + ConfigType + `
    data: ...
    applier: <applier name>
</pre>
`
```

We create such a config object for our service address and our config applier:

```go
	examplecfg, err := data.New(APPLIER, "localhost:8080")
	if err != nil {
		return errors.Wrapf(err, "invalid config data")
	}
```

Now, our config target can be configured as usual resulting in

```yaml
using service address: "localhost:8080"
```